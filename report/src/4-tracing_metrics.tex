\chapter{Tracing and Metrics}
Dopo aver fatto il deployment completo della nostra applicazione, abbiamo aggiunto il tracciamento delle chiamate che, a partire da un servizio, vengono propagate attraverso altri per completare una funzionalità.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tracing}
In applicazioni con migliaia di micro servizi, seguire la cascata di chiamate o valutare in che punto si è verificato un errore è molto complesso. Tramite il tracing non solo possiamo capire quale micro servizio viene chiamato e da chi, ma possiamo anche analizzare i tempi con cui ogni richiesta è stata servita, sia E2E che all'interno del singolo servizio.

\myskip

Il funzionamento solitamente è abbastanza semplice. Durante le varie chiamate viene trasmesso anche un ID (univoco) della traccia. Il trasporto di questo ID avviene tramite una qualche funzionalità del protocollo di trasporto: in HTTP viene usato il relativo header.

\subsection{OpenTelemetry}
OpenTelemetry, noto anche come \href{https://opentelemetry.io}{OTel}, è un insieme di tool e API che permette di collezionare ed esportare le telemetrie di un'applicazione a micro servizi. Oltre alle telemetrie in realtà possono anche essere gestite metriche e logs, ma in questo campo non è stabile e si preferisce usare altro (e.g., \href{https://micrometer.io}{MicroMeter}).

\myskip

Fornisce un protocollo, detto OTLP, che permette di esportare le telemetrie dalle applicazioni verso il tool OpenTelemetry Collector. A quest'ultimo si possono collegare vari back end (e.g., Jaeger) per la loro visualizzazione.

Usare il Collector non è necessario: si possono inviare i dati direttamente al backend: in piccole applicazioni è forse una scelta migliore per la facilità di manutenzione e configurazione; se l'applicazione deve scalare allora si hanno numero vantaggi usando il Collector, come il filtraggio, il batching e la riprova in caso di un qualche fallimento.

\myskip

Per utilizzare OTel nei vari micro servizi della nostra applicazione si deve semplicemente aggiungere l'estensione \textit{quarkus-opentelemetry}. In questo modo Quarkus inizia a collezionare telemetrie in automatico.

\subsection{Jaeger}
Come abbiamo detto \href{https://www.jaegertracing.io}{Jaeger} è un backend per la visualizzazione della cascate di chiamate all'interno di un applicazione a micro servizi.

Per permettere il suo funzionamento si deve aggiungere delle configurazioni nel file \textit{application.properties}. Queste configurazioni sono abbastanza standard e non dipendono molto dal microservizio specifico, se non per il nome che vogliamo visualizzare nella UI. Un esempio è quanto configurato per \textit{users-service} all'interno del Listing~\ref{lst:users-jaeger}. L'unica configurazione da spiegare è forte \texttt{quarkus.otel.traces.sampler=always\_on}: essa permette di non fare nessun campionamento delle chiamate, ma di considerarle e visualizzarle tutte; in questo modo non si rischia di interrompere una sequenza di chiamate.
\begin{lstlisting}[caption=Jaeger configuration for \textit{users-service}, label=lst:users-jaeger]
# jaeger
quarkus.kubernetes.env.vars.otel-service-name=users-service
quarkus.otel.resource.attributes=service.name=users-service
quarkus.kubernetes.env.vars.otel-exporter-otlp-endpoint=http://jaeger-collector:4317
quarkus.otel.exporter.otlp.endpoint=http://jaeger-collector:4317
quarkus.otel.traces.sampler=always_on
quarkus.log.console.format=%d{HH:mm:ss} %-5p traceId=%X{traceId}, parentId=%X{parentId}, spanId=%X{spanId}, sampled=%X{sampled} [%c{2.}] (%t) %s%e%n
\end{lstlisting}

\subsection{Jaeger deployment}
Come per i servizi terzi elencati nella Sezione~\ref{sec:servizi_esterni}, anche il backend Jaeger deve essere rilasciato nello stesso cluster Minikube di tutta l'applicazione.

Anche in questo caso è stato utilizzato il \href{https://artifacthub.io/packages/helm/jaegertracing/jaeger}{chart Helm Jaeger}. Si può vedere il comando nel Listing~\ref{lst:jaeger-helm}.
\begin{lstlisting}[caption=Install Jaeger chart for \textit{users-service}, label=lst:jaeger-helm]
helm install jaeger jaegertracing/jaeger \
    --set allInOne.enabled=true \
    --set agent.enabled=false \
    --set collector.enabled=false \
    --set query.enabled=false \
    --set provisionDataStore.cassandra=false \
    --set storage.type=memory
\end{lstlisting}
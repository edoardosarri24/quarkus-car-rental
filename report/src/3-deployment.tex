\chapter{Deployment}
In questo capitolo descriviamo il processo di deployment che è stato affrontato all'interno del progetto. Nonostante infatti l'applicazione fosse già sviluppata, è stato più complesso del previsto configurare l'ambiente e gestire le dipendenze tra i vari microservizi; sono stati richiesti infatti numerosi cambiamenti nel file di configurazione.

\myskip

Per automattizzare il deployment, nella root directory del progetto è fornito un eseguibile \textit{deployment.sh}: se avviato con il Docker demon in esecuzione allora verrà creato un cluster Minikube con tutti i micro servizi e le loro dipendenze. Il corretto funzionamento di questo script è garantito su MacBook M4 (ARM).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Environment}
Per il deployment del nostro progetto sono state prese delle decisioni in modo da semplificare il processo e renderlo fattibile senza utilizzare ambienti di produzione reali.

L'ambiente per il rilascio dell'applicazione è stato Minikube, un ambiente locale di sviluppo basato su Kubernetes. In questo modo è stato possibile testare il deployment in un ambiente simile a quello di produzione senza la necessità di risorse hardware dedicate. Nonostante l'applicazione rilasciata su GitHub sia completa e configurata per un tipo di deployment, ci sono stati vari aspetti da considerare e che hanno richiesto attenzione e tempo:
\begin{itemize}
    \item \textbf{OpenShift} \\
        L'applicazione era stata pensata per essere distributa su OpenShift, la piattaforma per container basata su Kubernetes e sviluppata da Red Hat. Nonostante essa si basi su Kubernetes, in Quarkus si richiede di specificare il tipo di ambiente di deployment all'interno del file di configurazione \textit{application.properties}. \\
        Un esempio di configurazione corretta per Kubernetes, usando Docker come runner di container, è quella mostrata nel Listing~\ref{lst:k8s_config}: questo è il contenuto del file di configurazione Quarkus per \textit{inventory-service}, ma generalizzando è lo stesso usato in tutti gli altri microservizi.
    \item \textbf{Registry} \\
        Una volta costruita l'immagine docker, il file di configurazione era progettato per eseguire il push su un registry, \textit{quay.io}, registry di Red Hat che fa parte dello stesso ecosistema di OpenShift. Siccome il nostro ambiente per il deployment era Minikube, sono state fatte delle modifiche anche in questo senso in modo da rilasciare l'immagine del microservizio all'interno di Minikube stesso.
    \item \textbf{Riferimenti} \\
        Usando ambienti di produzione diversi (OpenShift vs Minikube), si sono dovuti cambiare gli URL con cui un microservizio identificava le proprie dipendenze. Un esempio di quello che è stato fatto si trova nel Listing~\ref{lst:reference}, realtivo al miro servizio \textit{rental-service}: i riferimenti per l'ambiente di sviluppo sono stati lasciati invariati, mentre sono state confiugrate correttamente le variabili d'ambiente all'interno del container del micro servizio in modo che sia presente il riferimento alla dipendenza usata.
\end{itemize}

\begin{lstlisting}[caption=Kubernetes Configuration, label=lst:k8s_config]
# container
quarkus.container-image.build=true
quarkus.container-image.push=false
quarkus.container-image.group=edoardosarri
quarkus.container-image.name=inventory-service
quarkus.container-image.tag=1.1
# kubernetes
quarkus.kubernetes.name=inventory-service
quarkus.kubernetes.deployment-target=kubernetes
quarkus.kubernetes.service-type=NodePort
quarkus.kubernetes.image-pull-policy=IfNotPresent
\end{lstlisting}

\begin{lstlisting}[caption=Reference in different environments, label=lst:reference]
quarkus.rest-client.reservation.url=http://localhost:8081
quarkus.kubernetes.env.vars.quarkus-rest-client-reservation-url=http://reservation-service
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Servizi Esterni}
Come abbiamo già detto nella Sezione~\ref{sec:servizi_esterni}, i micro servizi principali utilizzano al loro interno altri servizi ausiliari. Questi devono eseguire all'interno dello stesso cluster Kubernetes di quelli principali e quindi devono essere in un qualche modo rilasciati.

La prima soluzione esplorata è stata farsi scrivere da un LLM il manifesto Kubernetes per l'ambiente Minikube. Nonostante questa fosse una soluzione funzionante, mi sembrava chiaro che ci potesse essere un'alternativa off-the-shelf. Dopo aver cercato ed essermi informato è deciso di utilizzare \href{https://helm.sh}{\textit{Helm}}~\cite{helm}.

\myskip

L'unico servizio esterno per cui è stato generato il manifesto invece che usare un chart (da un LLM, Gemini) è stato \href{https://www.mongodb.com/community/forums/t/mongodb-operator-install-instructions-for-minikube/10941}{MongoDB~\cite{mongodb}}. Il problema, che non sono riuscito a risolvere, è stato quella della compatibilità tra la versione di MongoDB e quella di Minikube.

\subsection{Helm}
Helm è un gestore di pacchetti Kubernetes che semplifica la gestione delle applicazioni Kubernetes.

Tramite i Chart possiamo definire, installare e aggiornare anche le applicazioni Kubernetes più complesse. Essi permettono infatti di non generare manifesti complessi e ridondanti a mano, ma di utilizzare una struttura predefinita e riutilizzabile. Nello stesso modo in cui esiste un database di immagini Docker, esiste un repository di Chart Helm, detto \href{https://artifacthub.io/}{ArtifactHUB}.

\subsection{Deployment con Helm}
Per capire come Helm semplifica il deployment di servizi terzi su cui un nostro micro servizio si può appoggiare prendiamo come esempio l'installazione del data base MySQL, necessario per \textit{inventory-service}. Tramite un comando, seguito da pochi parametri, come si vede nel Listing~\ref{lst:helm_mysql}, viene eseguito nel cluster Minikube un container MySQL.
\begin{lstlisting}[caption=MySQL Helm chart, label=lst:helm_mysql]
helm install mysql-inventory bitnami/mysql \
    --set auth.rootPassword=root-pass \
    --set auth.database=mysql-inventory \
    --set auth.username=user \
    --set auth.password=pass
\end{lstlisting}
\chapter{Workflow}
Nei Capitoli~\ref{cap:deployment} e \ref{cap:tracing-metrics} abbiamo visto come l'applicazione car rental, descritta nel Capitolo~\ref{cap:app}, viene rilasciata su Minikube e come possiamo analizzare metriche e workflow. In questo capitolo ci concentriamo invece sul workflow, cioè su come i microservizi si chiamano durante l'esecuzione di una funzionalità; in particolare la funzionalità che andremo ad esaminare sarà la prenotazione di una macchina.

Prima di qualunque modifica, come si nota dalla Figura~\ref{fig:initial_workflow}, \textit{Car-Rental} aveva un workflow esclusivamente sequenziale: quando un utente invocava una qualunque operazione, e in particolare \texttt{reserve}, tramite \textit{users-service}, la sequenza di chiamate agli altri microservizio era puramente sincrona e determinstica, cioè era sempre la stessa data l'operazione chiamata; ovviamente i tempi di esecuzione variano di chiamata in chiamata.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.7\textwidth]{images/5-workflow/initial_workflow_jaeger.pdf}
    \caption{Workflow iniziale di Car-Rental.}
    \label{fig:initial_workflow}
\end{figure}

\myskip

Il nostro obiettivo è, facendo riferimento sempre all'operazione \texttt{reserve}, complicare questo workflow. Facendo riferimento alla terminogia usata nell'articolo del tool Eulero~\cite{carnevali2023compositional}, che useremo più avanti, l'applicazione prima della modifica combina solamente blocchi di tipo sequenziale (\texttt{SEQ}), mentre a noi interessa aggiungere degli blocchi \texttt{XOR} e blocchi \texttt{AND}, che sono descritti nella Sezione~\ref{sec:blocchi} e implementati nella Sezione~\ref{sec:implementazione}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Blocchi}
\label{sec:blocchi}
Vediamo come prima cosa quali blocchi sono stati aggiunti e in che punto dell'attuale workflow sono stati eseguiti.

\subsection{XOR}
I blocchi XOR rappresentano scelte casuali esclusive definite da una certa probabilità. Questo vuol dire che se abbiamo $n$ possibili strade che il flusso può prendere, ne sarà scelta una e una soltanto una in base alla probabilità assegnata.

\subsection{AND}
I blocchi AND rappresentano esecuzioni indipendenti che possono essere eseguite in parallelo. Questo vuol dire che se abbiamo $n$ strade, tutte saranno eseguite contemporaneamente e si sincronizzeranno alla fine.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementazione}
\label{sec:implementazione}
Adesso che abbiamo visto quali blocchi vogliamo aggiungere, vediamo come sono stati implementati e in che punto del workflow vengono eseguiti.

La cosa importante da osservare è che l'obiettivo di questa modifica non è quello di aggiungere funzionalità all'applicazione, ma solamente quello di complicare il workflow. Per questo motivo ogni blocco aggiunto sarà composto da microservizi che non fanno altro che eseguire una busy wait per un tempo campionato da una distribuzione esponenziale; la busy wait è implementata con un ciclo \texttt{while} che controlla il tempo trascorso.

\subsection{XOR}
Il blocco XOR, che si trova nella cartella \href{https://github.com/edoardosarri24/quarkus-car-rental/tree/master/services/busywait-services/XOR}{XOR} su GitHub, implementa la scelta esculiva tra tre microservizi. Questo blocco è inserito nel flusso di \textit{users-service}: quest'ultimo microservizio chiama quello responsabile della scelta randomica e una volta che il blocco XOR termina riprende il controllo; in questo modo al codice dell'applicazione precedente è stata solo aggiunta la chiamata a questo blocco.

Il flusso del blocco XOR implementato è il seguente:
\begin{itemize}
    \item L'inizio del blocco è definito da \textit{start-choice-service}. Questo esegue una busy wait per un tempo campionato da una distribuzione esponenziale con tasso 1. Esegue poi una scelta randomica tra tre microservizio, dove: il primo ha probabilità 0.2, il secondo 0.5 e il terzo 0.3. Questo momento è utile per osservare un altro vantaggio di Quarkus: le probabilità con cui sono definite le scelte non sono build-in nel codice, ma sono definite del file \textit{application.properties}; questo permette di modificarle senza dover mettere mano al codice stesso.
    \item I tre microservizi chiamati sono \textit{first-choice-service}, \textit{second-choice-service} e \textit{third-choice-service}. Ognuno di questi esegue una busy wait per un tempo campionato da una distribuzione esponenziale con tasso 1. Al termine di uno di questi il controllo ritorna a \textit{users-service}
\end{itemize}

\subsection{AND}
Il blocco AND, che si trova nella cartella \href{https://github.com/edoardosarri24/quarkus-car-rental/tree/master/services/busywait-services/AND}{AND} su GitHub, implementa l'esecuzione parallela di due servizi chiamati dallo stesso microservizio client; i due server eseguono contemporaneamente e si sincronizzano nel client.

Anche questo blocco è inserito nel flusso di \textit{users-service}, esattamento dopo la chiamata al servizio \textit{start-choice}: il microservizio chiama \textit{start-parallel} che è il responsabile del fork; una volta che il blocco AND termina riprende il controllo; in questo modo al codice dell'applicazione precedente è stata solo aggiunta la chiamata a questo blocco.

\myskip

Per l'implementazione del blocco AND è stato usato gRPC, già descritto nella Sezione~\ref{sec:comunicazione}. In questo caso ha fatto la differenza l'utilizzo del framework Quarkus, che fornisce l'integrazione nativa con gRPC e permette di definire servizi asincroni in modo semplice.

La pipeline usata per implementare la comunicazione asincrona di gRPC con Quarkus è la seguente:
\begin{itemize}
    \item Il server dichiara un file \textit{.proto}, che definisce i servizi offerti e i messaggi scambiati. Questo permette di lavorare in modo API-first: si definisce cosa il server espone e si lavora a partire da questo.
    \item Con l'estensione \textit{quarkus-grpc}, quando si chiama \texttt{quarkus build}, il framework genera automaticamente tutto quello che ci serve per implementare il server. In particolare la classe che espone il servizio deve implementare un'interfaccia e sovrascrivere i metodi che nel file \textit{.proto} sono i messaggi scambiati.
    \item Il client deve memorizzare il file \textit{.proto}, compilarlo in modo che Quarkus generi lo stub del server e intrumentare il codice in modo da poter chiamare i metodi esposti dal server come se fossero locali.
\end{itemize}

\myskip

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.8\textwidth]{images/5-workflow/new_workflow_jaeger.pdf}
    \caption{Nuovo workflow di \texttt{reserve} mostrato da Jaeger.}
    \label{fig:new_workflow_jaeger}
\end{figure}

gRPC consente quindi di impelmentare una comunizione asincrona tra client e server tramite canali asincroni. Questo si può fare usando l'interfaccia nativa di gRPC o le API di SmallRye.

In gRPC Java classico questi canali sono gestiti dall'interfaccia \texttt{StreamObserver<T>}, dove \texttt{T} è il tipo del messaggio; ogni comuniazione è quindi un oggetto che implementa tale interfaccia. Quando si invia un messaggio tramite il canale (usando il metodo \texttt{onNext(T message)}), gRPC avvia un thread del suo pool di thread dedicati, il quale si occupa della gestione. Questa interfaccia ha però numerosi limiti: è imperativa e quindi tutto deve essere gestito a mano; si basa su callback, cioè molte funzioni vengono passate come parametro (uno \textit{StreamObserver} deve implementare tre metodi) e saranno chiamate in un secondo momento; è difficile da testare; non permette di gestire più risponde come un unico oggetto.

Quarkus, ovviamente, non utilizza questa interfaccia, ma sfrutta quella di SmallRye, \textit{Mutiny}. Si tratta di una libreria reattiva e dichiarativa: si deve definire come il sistema si comporta quando i dati arriveranno; non dobbiamo dire come fare le cose ma solo cosa vogliamo ottenere (e.g., nello stesso modo delle lambda). L'interfaccia di \textit{Mutiny} si basa su due tipi, \texttt{Uni<T>} e \texttt{Multi<T>}: il primo permette l'invio di un solo messaggio, mentre il secondo consente gli stream. I vantaggi che si ottengono sono: codice più leggibile; composizione di chiamate diverse facile da implementare; facile da testare e debuggare.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Nuovo workflow}
Nel nuovo workflow, oltre ad includere i blocchi \texttt{XOR} e \texttt{AND}, è stata eliminata la parte di fatturazione. Il motivo di questa scelta è in dovuto al nostro obiettivo che ci ha portato a complicare questo workflow: vogliamo valutare il tempo E2E di una prenotazione. La prenotazione e la fatturazione sono in car-rental due operazioni indipendenti: una prenotazione ha successo, e quindi ritorna all'utente, indipendentemente dal completamento della chiamata di \texttt{reservation-service} a \texttt{billing-service}.

Usando ancora Jeager per visualizzare la traccia della chiamata a \texttt{reserve}, possiamo notare dalla Figura~\ref{fig:new_workflow_jaeger} la presenza dei blocchi \texttt{XOR} e \texttt{AND} e l'esclusione dei microservizi \texttt{billing-service} e \texttt{rental-service}. In Figura~\ref{fig:new_workflow_sequence} è mostrato invece il sequence diagram UML.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{images/5-workflow/new_workflow_sequence.pdf}
    \caption{Sequence diagram dei blocchi XOR e AND.}
    \label{fig:new_workflow_sequence}
\end{figure}
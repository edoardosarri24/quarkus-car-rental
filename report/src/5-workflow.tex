\chapter{Workflow}
Nei Capitoli~\ref{cap:deployment} e \ref{cap:tracing-metrics} abbiamo visto come l'applicazione car rental, descritta nel Capitolo~\ref{cap:app}, viene rilasciata su Minikube e come possiamo analizzare metriche e workflow.

In questo capitolo ci concentriamo invece proprio sul workflow. Prima di qualunque modifica, \textit{Car-Rental} aveva un workflow esclusivamente sequenziale: quando un utente invocava una qualunque operazione tramite \textit{users-service}, la sequenza di chiamate agli altri microservizio era puramente sincrona e determinstica, cioè era sempre la stessa data l'operazione chiamata.

Per capire meglio osserviamo il workflow di una prenotazione da parte di un utente, mostrato in Figura~\ref{fig:jaeger_reservation}. Quando un utente chiama \texttt{reserve} tramite l'interfaccia grafica, si genere sempre la stessa cascata di chiamate; ovviamente i tempi di esecuzione variano di chiamata in chiamata.

\myskip

Il nostro obiettivo è adesso complicare questo workflow; faremo riferimento sempre a quello descritto sopra. Facendo riferimento alla terminogia usata nell'articolo del tool Eulero~\cite{carnevali2023compositional}, che useremo più avanti, l'applicazione prima della modifica combina solamente blocchi di tipo sequenziale (SEQ), mentre a noi interessa aggiungere degli blocchi XOR e blocchi AND, che sono descritti nella Sezione~\ref{sec:blocchi} e implementati nella Sezione~\ref{sec:implementazione}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Blocchi}
\label{sec:blocchi}
Vediamo come prima cosa quali blocchi sono stati aggiunti e in che punto dell'attuale workflow sono stati eseguiti. Da qui in poi considereremo la traccia fornita come esempio nella Figura~\ref{fig:jaeger_reservation}.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.8\textwidth]{images/5-workflow/STPN.pdf}
    \caption{Stochastic Time Petri Net example~\cite{carnevali2023compositional}.}
    \label{fig:STPN}
\end{figure}

\subsection{XOR}
I blocchi XOR, come mostrato in R2 in Figura~\ref{fig:STPN}, rappresentano scelte casuali esclusive definite da una certa probabilità. Questo vuol dire che se abbiamo $n$ possibili strade che il flusso può prendere, ne sarà scelta una e una soltanto una in base alla probabilità assegnata.

\subsection{AND}
I blocchi AND, come mostrato in X in Figura~\ref{fig:STPN}, rappresentano esecuzioni indipendenti che possono essere eseguite in parallelo. Questo vuol dire che se abbiamo $n$ strade, tutte saranno eseguite contemporaneamente e si sincronizzeranno alla fine.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementazione}
\label{sec:implementazione}
Adesso che abbiamo visto quali blocchi vogliamo aggiungere, vediamo come sono stati implementati e in che punto del workflow vengono eseguiti.

La cosa importante da osservare è che l'obiettivo di questa modifica non è quello di aggiungere funzionalità all'applicazione, ma solamente quello di complicare il workflow. Per questo motivo ogni blocco aggiunto sarà composto da microservizi che non fanno altro che eseguire una busy wait per un tempo campionato da una distribuzione esponenziale; la busy wait è implementata con un ciclo \texttt{while} che controlla il tempo trascorso.

\subsection{XOR}
Il blocco XOR implementa la scelta esculiva tra tre microservizi. Questo blocco è inserito nel flusso di \textit{users-service}: quest'ultimo microservizio chiama quello responsabile della scelta randomica e una volta che il blocco XOR termina riprende il controllo; in questo modo al codice dell'applicazione precedente è stata solo aggiunta la chiamata a questo blocco.

Il flusso del blocco XOR implementato è il seguente:
\begin{itemize}
    \item L'inizio del blocco è definito da \textit{start-choice-service}. Questo esegue una busy wait per un tempo campionato da una distribuzione esponenziale con tasso 1. Esegue poi una scelta randomica tra tre microservizio, dove: il primo ha probabilità 0.2, il secondo 0.5 e il terzo 0.3. Questo momento è utile per osservare un altro vantaggio di Quarkus: le probabilità con cui sono definite le scelte non sono build-in nel codice, ma sono definite del file \textit{application.properties}; questo permette di modificarle senza dover mettere mano al codice stesso.
    \item I tre microservizi chiamati sono \textit{first-choice-service}, \textit{second-choice-service} e \textit{third-choice-service}. Ognuno di questi esegue una busy wait per un tempo campionato da una distribuzione esponenziale con tasso 1. Al termine di uno di questi il controllo ritorna a \textit{users-service}
\end{itemize}

\subsection{AND}
Nella nostra applicazione è stato aggiunto un blocco AND tra i microservizi \textit{billing-service} e \textit{rental-service}. Il blocco è così composto:
\begin{itemize}
    \item Un nodo iniziale chiamato da \textit{billing-service} che chiama in parallelo i tre componenti successivi.
    \item Tre servizi che implementano una busy wait per un tempo campionato da una qualche distribuzione.
    \item Un nodo finale sul quale i tre precedenti componenti si sincronizzano e che successivamente restiuisce il comando a \textit{rental-service}.
\end{itemize}
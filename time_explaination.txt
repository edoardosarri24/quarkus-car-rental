Spiegazione del calcolo dei tempi nello script di analisi delle tracce (main.py)

Tutte le informazioni temporali provengono dai campi `startTimeUnixNano` e `endTimeUnixNano` presenti in ogni **span** (unità di lavoro tracciata) nel file `traces.json`.

### 1. Granular Segment Statistics (Tempi di esecuzione interni)
Questa metrica isola il **tempo di calcolo effettivo** ("Net Time") del servizio, sottraendo il tempo speso ad aspettare le chiamate esterne (verso altri microservizi).

*   **Come funziona:**
    1.  Lo script prende uno span di tipo `SERVER` (es. `users-service` riceve una richiesta).
    2.  Identifica tutti gli **span figli** (chiamate in uscita).
    3.  **Filtra le chiamate al DB:** Le chiamate al database (identificate dall'attributo `db.system`) vengono considerate parte dell'elaborazione interna e **NON** vengono sottratte.
    4.  **Sottrae le chiamate esterne:** Identifica le chiamate verso altri microservizi (es. verso `second-choice-service`).
    5.  **Segmentazione:** Il tempo totale dello span viene "tagliato" in segmenti di lavoro attivo:
        *   *Inizio Span* -> *Inizio Chiamata Esterna 1* = **Segmento 1** (es. "Processing before calling...")
        *   *Fine Chiamata Esterna 1* -> *Inizio Chiamata Esterna 2* = **Segmento 2**
        *   ...
        *   *Fine Ultima Chiamata Esterna* -> *Fine Span* = **Segmento Finale** ("Final Processing...")
    6.  Questi segmenti rappresentano il tempo in cui il servizio ha effettivamente lavorato (CPU o I/O locale/DB), escludendo l'attesa della risposta di altri servizi.

### 2. Service Total Statistics
Questa metrica è la **somma** dei tempi di tutti i "Granular Segments" calcolati per una specifica operazione di un servizio.
*   **Significato:** Rappresenta il tempo totale "netto" speso dal servizio, depurato dalle attese di rete/elaborazione dei microservizi chiamati a valle.
*   **Nota:** Se un servizio non effettua chiamate esterne verso altri servizi, questo tempo coincide esattamente con la durata totale dello span (`endTime` - `startTime`).

### 3. Network Latency Statistics (Latenza di Rete)
Viene calcolata confrontando la prospettiva del **Chiamante (Client)** con quella del **Ricevente (Server)** per la stessa interazione.

*   **Logica:**
    1.  Lo script accoppia uno span "figlio" (lato Server) con il suo span "genitore" (lato Client).
    2.  Calcola la **Durata Client** = `Client.endTime` - `Client.startTime`.
    3.  Calcola la **Durata Server** = `Server.endTime` - `Server.startTime`.
    4.  **Latenza (Overhead)** = `Durata Client` - `Durata Server`.
*   **Cosa rappresenta:** La differenza temporale include il tempo di viaggio di andata e ritorno (RTT - Round Trip Time) sulla rete, più l'overhead di serializzazione/deserializzazione dei messaggi e eventuali tempi di attesa nelle code interne dei framework prima che l'elaborazione inizi effettivamente.

### Riassunto visuale
Immagina una traccia temporale di una chiamata tra due servizi:

```text
[---------------- CLIENT SPAN (Parent) ----------------]
      \                                      /
       \ (Latenza andata + overhead)        / (Latenza ritorno + overhead)
        \                                  /
         [------- SERVER SPAN (Child) -------]
         | Calc1 |-> [Ext Call] ->| Calc2 |
```

*   **Granular Segments:** Sono i blocchi di elaborazione locale `Calc1` e `Calc2`.
*   **Service Total:** È la somma `Calc1 + Calc2`.
*   **Network Latency:** È la differenza `(Client Span Duration) - (Server Span Duration)`.
